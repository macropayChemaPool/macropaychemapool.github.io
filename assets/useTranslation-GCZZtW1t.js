import{r as l}from"./index-CBqU2yxZ.js";import{I as k,R as A,g as F,a as M}from"./context-DPnKhrhb.js";function P(){if(console&&console.warn){for(var s=arguments.length,e=new Array(s),n=0;n<s;n++)e[n]=arguments[n];typeof e[0]=="string"&&(e[0]=`react-i18next:: ${e[0]}`),console.warn(...e)}}const S={};function C(){for(var s=arguments.length,e=new Array(s),n=0;n<s;n++)e[n]=arguments[n];typeof e[0]=="string"&&S[e[0]]||(typeof e[0]=="string"&&(S[e[0]]=new Date),P(...e))}const z=(s,e)=>()=>{if(s.isInitialized)e();else{const n=()=>{setTimeout(()=>{s.off("initialized",n)},0),e()};s.on("initialized",n)}};function R(s,e,n){s.loadNamespaces(e,z(s,n))}function v(s,e,n,r){typeof n=="string"&&(n=[n]),n.forEach(i=>{s.options.ns.indexOf(i)<0&&s.options.ns.push(i)}),s.loadLanguages(e,z(s,r))}function j(s,e){let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};const r=e.languages[0],i=e.options?e.options.fallbackLng:!1,t=e.languages[e.languages.length-1];if(r.toLowerCase()==="cimode")return!0;const c=(w,m)=>{const o=e.services.backendConnector.state[`${w}|${m}`];return o===-1||o===2};return n.bindI18n&&n.bindI18n.indexOf("languageChanging")>-1&&e.services.backendConnector.backend&&e.isLanguageChangingTo&&!c(e.isLanguageChangingTo,s)?!1:!!(e.hasResourceBundle(r,s)||!e.services.backendConnector.backend||e.options.resources&&!e.options.partialBundledLanguages||c(r,s)&&(!i||c(t,s)))}function B(s,e){let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return!e.languages||!e.languages.length?(C("i18n.languages were undefined or empty",e.languages),!0):e.options.ignoreJSONStructure!==void 0?e.hasLoadedNamespace(s,{lng:n.lng,precheck:(i,t)=>{if(n.bindI18n&&n.bindI18n.indexOf("languageChanging")>-1&&i.services.backendConnector.backend&&i.isLanguageChangingTo&&!t(i.isLanguageChangingTo,s))return!1}}):j(s,e,n)}const J=(s,e)=>{const n=l.useRef();return l.useEffect(()=>{n.current=s},[s,e]),n.current};function E(s,e,n,r){return s.getFixedT(e,n,r)}function O(s,e,n,r){return l.useCallback(E(s,e,n,r),[s,e,n,r])}function H(s){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const{i18n:n}=e,{i18n:r,defaultNS:i}=l.useContext(k)||{},t=n||r||M();if(t&&!t.reportNamespaces&&(t.reportNamespaces=new A),!t){C("You will need to pass in an i18next instance by using initReactI18next");const a=(g,u)=>typeof u=="string"?u:u&&typeof u=="object"&&typeof u.defaultValue=="string"?u.defaultValue:Array.isArray(g)?g[g.length-1]:g,f=[a,{},!1];return f.t=a,f.i18n={},f.ready=!1,f}t.options.react&&t.options.react.wait!==void 0&&C("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const c={...F(),...t.options.react,...e},{useSuspense:w,keyPrefix:m}=c;let o=i||t.options&&t.options.defaultNS;o=typeof o=="string"?[o]:o||["translation"],t.reportNamespaces.addUsedNamespaces&&t.reportNamespaces.addUsedNamespaces(o);const p=(t.isInitialized||t.initializedStoreOnce)&&o.every(a=>B(a,t,c)),$=O(t,e.lng||null,c.nsMode==="fallback"?o:o[0],m),x=()=>$,y=()=>E(t,e.lng||null,c.nsMode==="fallback"?o:o[0],m),[I,h]=l.useState(x);let N=o.join();e.lng&&(N=`${e.lng}${N}`);const L=J(N),d=l.useRef(!0);l.useEffect(()=>{const{bindI18n:a,bindI18nStore:f}=c;d.current=!0,!p&&!w&&(e.lng?v(t,e.lng,o,()=>{d.current&&h(y)}):R(t,o,()=>{d.current&&h(y)})),p&&L&&L!==N&&d.current&&h(y);function g(){d.current&&h(y)}return a&&t&&t.on(a,g),f&&t&&t.store.on(f,g),()=>{d.current=!1,a&&t&&a.split(" ").forEach(u=>t.off(u,g)),f&&t&&f.split(" ").forEach(u=>t.store.off(u,g))}},[t,N]);const T=l.useRef(!0);l.useEffect(()=>{d.current&&!T.current&&h(x),T.current=!1},[t,m]);const b=[I,t,p];if(b.t=I,b.i18n=t,b.ready=p,p||!p&&!w)return b;throw new Promise(a=>{e.lng?v(t,e.lng,o,()=>a()):R(t,o,()=>a())})}export{H as u};
